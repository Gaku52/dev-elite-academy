# 基本情報技術者試験：システム開発とプロジェクト管理

> **作成日**: 2025年10月28日
> **目的**: システム開発手法とプロジェクト管理の本質を理解する

---

## 目次

1. [システム開発手法](#1-システム開発手法)
2. [要件定義と設計](#2-要件定義と設計)
3. [テスト手法](#3-テスト手法)
4. [プロジェクト管理](#4-プロジェクト管理)
5. [UML図解](#5-uml図解)

---

## 1. システム開発手法

### 1-1. ウォーターフォールモデル

**特徴**: 上流から下流へ一方向に進む

```
【開発工程】

要件定義 ─────→ 何を作るか決定
   ↓
外部設計 ─────→ ユーザーから見た仕様
   ↓
内部設計 ─────→ システム内部の詳細設計
   ↓
プログラミング ─→ コーディング
   ↓
テスト ───────→ 品質確認
   ↓
運用・保守 ────→ リリース後の維持管理
```

**メリット**:
- 計画が立てやすい
- 進捗が管理しやすい
- ドキュメントが整備される
- 大規模プロジェクトに向く

**デメリット**:
- 後戻りが困難
- 初期に全要件が必要
- 変更に弱い
- 最終工程まで動作確認できない

**向いているプロジェクト**:
```
✅ 要件が明確で変更が少ない
✅ 法規制が厳しい（金融、医療）
✅ 大規模システム
✅ 契約が固定的

❌ 要件が不明確
❌ 市場変化が激しい
❌ 小規模で素早いリリースが必要
```

---

### 1-2. プロトタイピングモデル

**試作品を作って確認しながら開発**

```
【プロセス】

1. 初期要件定義
   ↓
2. プロトタイプ作成（試作品）
   ↓
3. ユーザー評価
   ↓
4. フィードバック反映
   ↓
5. 2〜4を繰り返す
   ↓
6. 本番開発
```

**メリット**:
- 早期に動作を確認できる
- ユーザーの意見を取り入れやすい
- 誤解や認識違いを防げる

**デメリット**:
- スケジュール管理が難しい
- プロトタイプが本番品質でない
- 何度も作り直すコスト

**向いているプロジェクト**:
```
✅ UI/UXが重要
✅ 要件が曖昧
✅ ユーザーとの認識合わせが必要
```

---

### 1-3. スパイラルモデル

**リスクを重視して段階的に開発**

```
【スパイラル（螺旋）の各サイクル】

1回目: 最も重要な機能を開発
   ↓
2回目: 次に重要な機能を追加
   ↓
3回目: さらに機能を追加
   ↓
完成

各サイクルで:
計画 → リスク分析 → 開発 → 評価
```

**メリット**:
- リスクを早期発見
- 段階的にリリース可能
- 柔軟な変更対応

**デメリット**:
- 管理が複雑
- リスク分析に時間がかかる

---

### 1-4. アジャイル開発（スクラム）

**短期間（1〜4週間）で動くソフトウェアを繰り返しリリース**

```
【スクラムの構成】

スプリント（1〜4週間の開発サイクル）

スプリント計画
   ↓
デイリースクラム（毎日15分の進捗確認）
   ↓
開発・テスト
   ↓
スプリントレビュー（成果物のデモ）
   ↓
スプリントレトロスペクティブ（振り返り）
   ↓
次のスプリントへ
```

**役割**:

| 役割 | 責任 |
|------|------|
| **プロダクトオーナー** | 何を作るかを決定（優先順位） |
| **スクラムマスター** | チームを支援、障害除去 |
| **開発チーム** | 実装・テスト |

**メリット**:
- 変化に強い
- 早期リリース可能
- ユーザーフィードバックを即反映
- チームの自律性が高い

**デメリット**:
- 計画が立てにくい
- ドキュメントが不足しがち
- チームの習熟が必要

**向いているプロジェクト**:
```
✅ Webサービス、スマホアプリ
✅ 要件が変化する
✅ 小〜中規模
✅ スタートアップ

❌ 法規制が厳しい
❌ 契約が固定的
❌ 超大規模システム
```

---

### 1-5. DevOps

**開発（Development）と運用（Operations）の融合**

```
【DevOpsのサイクル】

計画 → コード → ビルド → テスト
  ↑                        ↓
監視 ← 運用 ← リリース ← デプロイ
```

**重要な概念**:

```
【CI/CD】
CI (Continuous Integration): 継続的インテグレーション
→ コードを頻繁にマージ・テスト

CD (Continuous Delivery/Deployment): 継続的デリバリー/デプロイ
→ 自動テスト・自動デプロイ

メリット:
- バグの早期発見
- リリース頻度の向上
- 手動作業の削減
```

**自動化の例**:
```
1. コードをGitにpush
   ↓ 自動
2. ビルド実行
   ↓ 自動
3. 単体テスト実行
   ↓ 自動
4. 本番環境へデプロイ
   ↓ 自動
5. 監視・アラート
```

---

## 2. 要件定義と設計

### 2-1. 要件定義

**機能要件 vs 非機能要件**

| 要件の種類 | 内容 | 例 |
|-----------|------|-----|
| **機能要件** | システムが持つべき機能 | ログイン機能、検索機能 |
| **非機能要件** | 性能、品質に関する要件 | レスポンス1秒以内、稼働率99.9% |

**非機能要件の例**:
```
性能:
- レスポンスタイム: 1秒以内
- 同時接続数: 10,000人

可用性:
- 稼働率: 99.9%以上
- 年間ダウンタイム: 8時間以内

セキュリティ:
- パスワードの暗号化
- 通信のHTTPS化

拡張性:
- ユーザー数10倍に対応可能
```

---

### 2-2. 外部設計と内部設計

**外部設計（ユーザー視点）**:
- 画面レイアウト
- 画面遷移
- 帳票設計
- 入出力仕様

**内部設計（システム視点）**:
- データベース設計（ER図、テーブル定義）
- クラス設計
- インターフェース設計
- アルゴリズム設計

---

### 2-3. データベース設計

#### ER図（Entity Relationship Diagram）

**基本記号**:

```
【エンティティ（実体）】
┌────────────┐
│   社員     │
├────────────┤
│ 社員ID     │← 主キー
│ 名前       │
│ 部署ID     │← 外部キー
└────────────┘

【リレーションシップ（関連）】

社員 ──<  所属  >── 部署
     1           N

1対多（一人の社員は一つの部署に所属）
      （一つの部署には複数の社員が所属）
```

**多対多の解決**:

```
【問題】
学生 ──<  履修  >── 授業
     N           N

一人の学生は複数の授業を履修
一つの授業には複数の学生が参加
→ 直接関連付けできない

【解決】
学生 ── 1:N ── 履修テーブル ── N:1 ── 授業

履修テーブル:
| 学生ID | 授業ID | 成績 |
|--------|--------|------|
| S001   | C001   | A    |
| S001   | C002   | B    |
| S002   | C001   | A    |

★中間テーブルで多対多を解消
```

---

## 3. テスト手法

### 3-1. テストレベル

```
【V字モデル】

要件定義 ───────→ システムテスト
   ↓                    ↑
外部設計 ───────→ 結合テスト
   ↓                    ↑
内部設計 ───────→ 単体テスト
   ↓                    ↑
コーディング ←─────────┘
```

#### 単体テスト（Unit Test）

**目的**: 個別のモジュール・関数の動作確認

```
【テスト例】

関数: add(a, b) → a + bを返す

テストケース:
1. add(2, 3) → 5  ✅
2. add(-1, 1) → 0 ✅
3. add(0, 0) → 0  ✅
4. add(1000, 2000) → 3000 ✅
```

**担当**: プログラマー

---

#### 結合テスト（Integration Test）

**目的**: 複数のモジュールを組み合わせて動作確認

```
【テスト例】

ログイン機能:
1. 入力画面 → バリデーション → データベース照合
2. 正常系: ログイン成功
3. 異常系: パスワード間違い → エラー表示
```

**結合方法**:

| 方式 | 説明 | メリット | デメリット |
|------|------|----------|-----------|
| **トップダウン** | 上位モジュールから統合 | 早期に全体像把握 | 下位モジュールのスタブ必要 |
| **ボトムアップ** | 下位モジュールから統合 | 詳細機能を先に確認 | 全体像の把握が遅い |

**スタブ**:
```
未完成の下位モジュールの代わりに使う仮実装

例:
関数getUserData(id):
    # 実装前なので固定値を返す
    return {"id": id, "name": "テストユーザー"}
```

**ドライバ**:
```
未完成の上位モジュールの代わりに使うテスト用プログラム

例:
# 関数calculatePrice()をテストするドライバ
result = calculatePrice(100, 2)
print(result)  # 期待値: 200
```

---

#### システムテスト

**目的**: システム全体が要件を満たすか確認

```
【テスト項目】
- 機能テスト: 全機能が正常動作するか
- 性能テスト: レスポンスタイム、負荷耐性
- セキュリティテスト: 脆弱性検証
- ユーザビリティテスト: 使いやすさ
```

**担当**: テスト専門チーム

---

#### 受け入れテスト（Acceptance Test）

**目的**: 顧客が要件を満たしているか最終確認

**担当**: 顧客・ユーザー

---

### 3-2. ブラックボックステストとホワイトボックステスト

#### ブラックボックステスト

**内部構造を見ずに、入出力だけで判断**

```
【同値分割】

入力: 年齢（0〜100）

クラス分類:
1. 無効値（負の数）: -5
2. 有効値（0〜17）: 10  ← 未成年
3. 有効値（18〜100）: 30 ← 成人
4. 無効値（101以上）: 150

各クラスから1つずつテスト
```

```
【境界値分析】

境界付近をテスト

例: 成人判定（18歳以上）
テストケース:
- 17歳（境界-1）
- 18歳（境界）
- 19歳（境界+1）

★バグは境界で発生しやすい
```

---

#### ホワイトボックステスト

**内部構造（コード）を見てテスト**

```
【命令網羅（C0）】
全ての命令を最低1回実行

【分岐網羅（C1）】
全ての分岐（if文のTrueとFalse）を実行

【条件網羅（C2）】
全ての条件の組み合わせを実行
```

**例**:
```python
def check(a, b):
    if a > 0 and b > 0:  # 条件1: a>0, 条件2: b>0
        return "Both positive"
    else:
        return "Not both positive"

【C0: 命令網羅】
テストケース1: check(1, 1) → "Both positive" ✅

【C1: 分岐網羅】
テストケース1: check(1, 1) → "Both positive"  ✅
テストケース2: check(-1, 1) → "Not both positive" ✅

【C2: 条件網羅】
テストケース1: check(1, 1)   → a>0=T, b>0=T
テストケース2: check(1, -1)  → a>0=T, b>0=F
テストケース3: check(-1, 1)  → a>0=F, b>0=T
テストケース4: check(-1, -1) → a>0=F, b>0=F

★C2が最も厳密
```

---

## 4. プロジェクト管理

### 4-1. WBS（Work Breakdown Structure）

**作業を階層的に分解**

```
【WBSの例: ECサイト開発】

ECサイト開発
├── 要件定義
│   ├── ヒアリング
│   └── 要件書作成
├── 設計
│   ├── 画面設計
│   ├── DB設計
│   └── API設計
├── 開発
│   ├── ユーザー管理機能
│   ├── 商品管理機能
│   ├── カート機能
│   └── 決済機能
└── テスト
    ├── 単体テスト
    ├── 結合テスト
    └── システムテスト
```

**WBSの目的**:
- 作業の見落とし防止
- 工数見積もりの精度向上
- 担当者の割り当て

---

### 4-2. ガントチャート

**時間軸に沿った作業スケジュール**

```
【ガントチャートの例】

タスク        | 1週 2週 3週 4週 5週 6週
─────────────┼──────────────────────
要件定義      |■■
設計          |  ■■■
開発（機能A）  |    ■■■
開発（機能B）  |      ■■■
テスト        |        ■■■
リリース      |          ■

■ = 作業期間
```

**メリット**:
- 視覚的にわかりやすい
- スケジュール全体を把握できる

**デメリット**:
- タスク間の依存関係がわかりにくい

---

### 4-3. PERT図（Program Evaluation and Review Technique）

**タスクの依存関係を矢線で表現**

```
【PERT図の例】

     5日      10日     8日
 ○─────→○─────→○─────→○
要件定義   設計    開発    テスト

結合点で複数タスクが合流:

      ┌─ 機能A開発（5日）─┐
要件  ─┤                  ├─ 結合テスト
      └─ 機能B開発（7日）─┘
```

**クリティカルパス**:
```
最も時間がかかる経路

上記の例:
経路1: 要件 → 機能A → 結合 = 5日
経路2: 要件 → 機能B → 結合 = 7日 ← クリティカルパス

★機能Bが遅れると全体が遅れる
```

**計算問題（頻出）**:

**例題1**:
```
【問題】
以下のタスクがある:

A: 要件定義（5日）
B: 設計（10日）← Aの後
C: DB設計（7日）← Aの後
D: 開発（15日）← B, Cの後
E: テスト（8日）← Dの後

プロジェクトの最短完了日数は？

【解答】
経路1: A → B → D → E
     = 5 + 10 + 15 + 8
     = 38日

経路2: A → C → D → E
     = 5 + 7 + 15 + 8
     = 35日

クリティカルパス = 経路1（38日）

答え: 38日
```

---

### 4-4. アローダイアグラム

**PERT図の一種、丸と矢印で表現**

```
【表記法】

   5日
①───→②

①: 開始イベント
②: 終了イベント
矢印: 作業（アクティビティ）
数字: 所要日数
```

**ダミー作業**:
```
依存関係を表すが時間ゼロの作業

例:
   5日        10日
①───→②─────→④
   ↓ ダミー ↗
   7日     ↑
   ③───────┘

★②が完了しないと④は開始できない
  （ダミーで依存関係を表現）
```

---

## 5. UML図解

### 5-1. クラス図

**クラスの構造と関連を表現**

```
【クラス図の例】

┌────────────────┐
│    Person      │← クラス名
├────────────────┤
│ - name: String │← 属性（-はprivate）
│ - age: int     │
├────────────────┤
│ + getName()    │← メソッド（+はpublic）
│ + getAge()     │
└────────────────┘
```

**関連の種類**:

```
【汎化（継承）】
      Animal
         △
         │
    ─────┴─────
    │         │
   Dog       Cat

【集約】
  Company ◇─── Employee
  （会社は社員を集約）

【コンポジション】
  House ◆─── Room
  （家は部屋で構成、家がなくなると部屋もなくなる）

【依存】
  Class1 ----→ Class2
  （Class1がClass2を使用）
```

---

### 5-2. シーケンス図

**オブジェクト間のやり取りを時系列で表現**

```
【シーケンス図の例: ログイン処理】

ユーザー     画面      サーバー    DB
  │          │         │         │
  │ログイン   │         │         │
  │─────────→│         │         │
  │          │認証要求  │         │
  │          │────────→│         │
  │          │         │ユーザー  │
  │          │         │検索     │
  │          │         │────────→│
  │          │         │結果     │
  │          │         │←───────│
  │          │認証結果  │         │
  │          │←───────│         │
  │成功画面   │         │         │
  │←─────────│         │         │
  │          │         │         │

縦線: オブジェクトの生存期間
横矢印: メッセージ
```

---

### 5-3. ユースケース図

**システムの機能をユーザー視点で表現**

```
【ユースケース図の例: ECサイト】

     ┌─────────────────────┐
     │                     │
     │   ┌───────────┐     │
     │   │商品検索    │     │
     │   └───────────┘     │
     │         │           │
  ──→│   ┌───────────┐     │
顧客  │   │カート追加  │     │
     │   └───────────┘     │
     │         │           │
     │   ┌───────────┐     │
     │   │決済       │     │
     │   └───────────┘     │
     │                     │
     └─────────────────────┘
          システム境界

棒人間: アクター（ユーザー）
楕円: ユースケース（機能）
線: 関連
```

---

## まとめ：試験対策のポイント

### 開発手法の使い分け

| 手法 | 特徴 | 向いている |
|------|------|-----------|
| **ウォーターフォール** | 計画重視、後戻り困難 | 大規模、要件固定 |
| **アジャイル** | 変化対応、短期リリース | 小〜中規模、変化激しい |
| **プロトタイピング** | 試作で確認 | UI/UX重視 |
| **スパイラル** | リスク重視 | リスク高い案件 |

### テストの種類

```
レベル: 単体 → 結合 → システム → 受け入れ
視点: ホワイトボックス（内部）
     ブラックボックス（外部）
```

### プロジェクト管理

```
WBS: 作業分解
ガントチャート: スケジュール可視化
PERT図: 依存関係とクリティカルパス
```

### UMLの種類

```
クラス図: 静的構造
シーケンス図: 動的な振る舞い（時系列）
ユースケース図: ユーザー視点の機能
```

---

**このノートでシステム開発とプロジェクト管理の本質を理解しよう！**

**頑張ってください！** 🚀
