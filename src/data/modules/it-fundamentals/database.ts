import { Module } from '@/types/learning';

export const learningModules: Module[] = [
  {
    id: 1,
    title: 'データベース基礎',
    sections: [
      {
        title: '3層スキーマとデータモデル',
        content: `データベースシステムの基本的な構造とデータモデルについて学習します。

**3層スキーマ構造:**
- **外部スキーマ**: ユーザー視点のデータベース（ビュー）
- **概念スキーマ**: データベース全体の論理的構造
- **内部スキーマ**: 物理的なデータ格納方法

**データモデルの種類:**
- **階層モデル**: 木構造によるデータ表現
- **ネットワークモデル**: グラフ構造によるデータ表現
- **関係モデル**: 表（テーブル）によるデータ表現
- **オブジェクト指向モデル**: オブジェクトによるデータ表現

**データ独立性:**
- **論理的独立性**: 概念スキーマの変更が外部スキーマに影響しない
- **物理的独立性**: 内部スキーマの変更が概念スキーマに影響しない

これらの概念により、データベースシステムの柔軟性と保守性が確保されます。`,
        quizzes: [
          {
            question: 'データベースの3層スキーマ構造で、実際にデータが格納される層は？',
            options: ['外部スキーマ', '概念スキーマ', '内部スキーマ', '論理スキーマ'],
            correct: 2,
            explanation: '内部スキーマは物理的なデータの格納方法を定義し、実際にデータが格納される層です。'
          },
          {
            question: 'ビューの利点として適切でないものは？',
            options: ['セキュリティの向上', 'データの論理的独立性', 'ストレージ容量の削減', 'データアクセスの簡素化'],
            correct: 2,
            explanation: 'ビューは仮想的なテーブルであり、実際のデータは基となるテーブルに格納されるため、ストレージ容量は削減されません。'
          },
          {
            question: 'NoSQLデータベースの特徴として正しいものは？',
            options: ['ACID特性を厳密に保証', 'スキーマレス設計', 'SQL言語の使用', '正規化が必須'],
            correct: 1,
            explanation: 'NoSQLデータベースの多くはスキーマレス設計を採用し、固定的なスキーマを必要としません。'
          },
          {
            question: 'NoSQLデータベースのタイプでないものは？',
            options: ['ドキュメント型', 'キー・バリュー型', 'グラフ型', 'リレーショナル型'],
            correct: 3,
            explanation: 'リレーショナル型は従来のRDBMSであり、NoSQLのタイプではありません。'
          },
          {
            question: 'データウェアハウスの特徴として適切でないものは？',
            options: ['主にOLAP用途', '時系列データの保持', 'リアルタイム更新', '大容量データの格納'],
            correct: 2,
            explanation: 'データウェアハウスは分析用途に最適化されており、リアルタイム更新よりもバッチ処理による定期更新が一般的です。'
          },
          {
            question: 'OLTPシステムの特徴として正しいものは？',
            options: ['大量データの分析', '複雑な集計処理', '短時間の単純な処理', '履歴データの保持'],
            correct: 2,
            explanation: 'OLTP（Online Transaction Processing）は短時間で完了する単純なトランザクション処理が特徴です。'
          }
        ]
      },
      {
        title: 'データマイニングとビッグデータ',
        content: `大量データの分析とデータマイニング技術について学習します。

**データマイニング手法:**
- **クラスタリング**: データを類似性に基づいてグループ化
- **分類**: 既知のカテゴリに基づいてデータを分類
- **相関ルール**: データ間の関連性を発見
- **回帰分析**: 数値の予測を行う

**ビッグデータの3V:**
- **Volume（量）**: 大量のデータ
- **Velocity（速度）**: 高速なデータ処理
- **Variety（多様性）**: 多種多様なデータ形式

**データ前処理:**
- **データクレンジング**: データの品質向上
- **データ統合**: 複数のデータソースの統合
- **データ変換**: 分析に適した形式への変換

これらの技術により、膨大なデータから有用な知識を抽出できます。`,
        quizzes: [
          {
            question: 'データマイニングの手法でないものは？',
            options: ['クラスタリング', '分類', 'データクレンジング', '相関ルール'],
            correct: 2,
            explanation: 'データクレンジングはデータの品質向上を目的とした前処理で、データマイニング手法ではありません。'
          },
          {
            question: 'BigDataの3Vに含まれないものは？',
            options: ['Volume（量）', 'Velocity（速度）', 'Variety（多様性）', 'Validity（妥当性）'],
            correct: 3,
            explanation: 'BigDataの3Vは Volume（量）、Velocity（速度）、Variety（多様性）です。'
          },
          {
            question: 'データベースのETL処理の「T」は何を表すか？',
            options: ['Transfer', 'Transform', 'Track', 'Transaction'],
            correct: 1,
            explanation: 'ETLのTはTransform（変換）を表し、データの形式変換や加工を行います。'
          },
          {
            question: 'データベースのData lineageとは？',
            options: ['データサイズ', 'データの系譜・来歴', 'データタイプ', 'データ暗号化'],
            correct: 1,
            explanation: 'Data lineageはデータの起源、変換過程、流れを追跡・可視化する概念です。'
          }
        ]
      }
    ]
  },
  {
    id: 2,
    title: '関係データベース',
    sections: [
      {
        title: 'リレーショナルモデルと制約',
        content: `関係データベースの基本概念と整合性制約について学習します。

**関係データベースの構成要素:**
- **テーブル（関係）**: データを行と列で表現
- **行（タプル）**: 個々のデータレコード
- **列（属性）**: データの項目

**キーの種類:**
- **主キー**: 行を一意に識別するキー（重複不可、NULL不可）
- **外部キー**: 他のテーブルを参照するキー
- **候補キー**: 主キーになり得るキー
- **複合キー**: 複数の列で構成されるキー

**整合性制約:**
- **実体整合性**: 主キーは一意でNULL値を持たない
- **参照整合性**: 外部キーは参照先に存在する値またはNULL
- **ドメイン整合性**: 各属性は定義された範囲の値のみ

これらの制約により、データの一貫性と信頼性が保たれます。`,
        quizzes: [
          {
            question: '関係データベースにおいて、主キーの制約として正しいものは？',
            options: ['重複可能、NULL可能', '重複不可、NULL可能', '重複可能、NULL不可', '重複不可、NULL不可'],
            correct: 3,
            explanation: '主キーは一意性制約と非NULL制約の両方を持ち、重複不可でNULL値も許可されません。'
          },
          {
            question: 'データベースの整合性制約で、参照整合性を保つための制約は？',
            options: ['CHECK制約', 'NOT NULL制約', '外部キー制約', 'UNIQUE制約'],
            correct: 2,
            explanation: '外部キー制約は参照整合性を保ち、参照先のテーブルに存在しない値の挿入を防ぎます。'
          },
          {
            question: 'データベースのロールベースアクセス制御（RBAC）の概念は？',
            options: ['ユーザーに直接権限付与', '役割に権限を付与し、ユーザーに役割を割当', 'パスワードによる認証のみ', 'IPアドレスによる制御'],
            correct: 1,
            explanation: 'RBACでは役割（ロール）に権限を付与し、ユーザーには役割を割り当てることで権限管理を簡素化します。'
          },
          {
            question: 'データベースのファンクション従属とは？',
            options: ['テーブル間の関係', '列間の依存関係', 'インデックスの種類', 'ロックの種類'],
            correct: 1,
            explanation: 'ファンクション従属は、ある列の値が決まれば他の列の値が一意に決まる関係です。'
          }
        ]
      },
      {
        title: 'レプリケーションとクラスタリング',
        content: `データベースの可用性と性能向上のためのレプリケーションとクラスタリング技術について学習します。

**レプリケーション方式:**
- **マスター・スレーブ方式**: マスターが更新、スレーブが読み取り専用
- **マスター・マスター方式**: 複数のマスターで相互レプリケーション
- **リードレプリカ**: 読み取り負荷分散のための専用レプリカ

**クラスタリング:**
- **アクティブ・パッシブ**: 一方が稼働、他方が待機
- **アクティブ・アクティブ**: 複数ノードが同時稼働
- **共有ディスク**: 複数ノードが同じストレージを共有
- **シェアードナッシング**: 各ノードが独立したリソースを持つ

**高可用性技術:**
- **Hot Standby**: 自動フェイルオーバー可能な待機系
- **Cold Standby**: 手動切り替えが必要な待機系
- **ロードバランシング**: 負荷分散による性能向上

これらの技術により、システムの可用性と拡張性が向上します。`,
        quizzes: [
          {
            question: 'データベースのレプリケーションで、マスター・スレーブ方式の特徴は？',
            options: ['すべてのノードで更新可能', 'マスターのみ更新可能', '自動負荷分散', 'データの暗号化'],
            correct: 1,
            explanation: 'マスター・スレーブ方式では、マスターノードのみが更新処理を行い、スレーブは読み取り専用です。'
          },
          {
            question: 'データベースのクラスタリングの主な目的は？',
            options: ['データの暗号化', '高可用性の実現', 'データの圧縮', 'バックアップの高速化'],
            correct: 1,
            explanation: 'クラスタリングの主目的は複数のサーバで冗長化を図り、高可用性（HA）を実現することです。'
          },
          {
            question: 'データベースのリードレプリカの主な用途は？',
            options: ['書き込み性能向上', '読み取り負荷分散', 'データ暗号化', 'バックアップ高速化'],
            correct: 1,
            explanation: 'リードレプリカは読み取り専用のレプリカで、読み取り負荷を分散するために使用されます。'
          },
          {
            question: 'データベースのHot Standbyの特徴は？',
            options: ['手動切り替えのみ', '自動フェイルオーバー可能', 'データ同期なし', 'リードアクセス不可'],
            correct: 1,
            explanation: 'Hot Standbyは常にデータが同期されており、自動フェイルオーバーによる高可用性を実現できます。'
          }
        ]
      }
    ]
  },
  {
    id: 3,
    title: 'SQL基礎',
    sections: [
      {
        title: 'SELECT文と結合',
        content: `SQLの基本的なクエリ作成と表の結合について学習します。

**SELECT文の基本構文:**
\`\`\`sql
SELECT column1, column2, ...
FROM table_name
WHERE condition
ORDER BY column_name;
\`\`\`

**JOIN操作の種類:**
- **INNER JOIN**: 両テーブルで条件に一致する行のみ
- **LEFT JOIN**: 左テーブルの全行と右テーブルの一致行
- **RIGHT JOIN**: 右テーブルの全行と左テーブルの一致行
- **FULL OUTER JOIN**: 両テーブルの全行

**WHERE句とHAVING句:**
- **WHERE**: 行の条件指定（集約前）
- **HAVING**: グループの条件指定（集約後、集約関数使用可能）

**その他の重要な句:**
- **GROUP BY**: データのグループ化
- **ORDER BY**: 結果の並び替え
- **DISTINCT**: 重複行の除去

これらのSQL文により、複雑なデータ検索と操作が可能になります。`,
        quizzes: [
          {
            question: 'SQLのJOIN操作で、両テーブルの一致する行のみを取得するのは？',
            options: ['LEFT JOIN', 'RIGHT JOIN', 'INNER JOIN', 'FULL OUTER JOIN'],
            correct: 2,
            explanation: 'INNER JOINは両テーブルで結合条件に一致する行のみを取得します。'
          },
          {
            question: 'SQLのWHERE句で使用できない集約関数を使用する場合は？',
            options: ['ORDER BY句', 'GROUP BY句', 'HAVING句', 'SELECT句'],
            correct: 2,
            explanation: 'HAVING句は集約関数を使った条件指定に使用され、WHERE句では集約関数は使用できません。'
          },
          {
            question: 'SQLのFULL OUTER JOINの結果として正しいものは？',
            options: ['左テーブルの全行', '右テーブルの全行', '両テーブルの一致行のみ', '両テーブルの全行'],
            correct: 3,
            explanation: 'FULL OUTER JOINは左右両方のテーブルの全行を取得し、一致しない行はNULLで埋められます。'
          },
          {
            question: 'SQLのCOALESCE関数の動作は？',
            options: ['最大値を返す', '最小値を返す', '最初の非NULL値を返す', '平均値を返す'],
            correct: 2,
            explanation: 'COALESCE関数は引数の中で最初に見つかった非NULL値を返します。'
          }
        ]
      },
      {
        title: '集約関数とサブクエリ',
        content: `SQLの集約関数、ウィンドウ関数、サブクエリについて学習します。

**集約関数:**
- **COUNT()**: 行数をカウント
- **SUM()**: 合計値を計算
- **AVG()**: 平均値を計算
- **MAX()/MIN()**: 最大値/最小値を取得
- **GROUP_CONCAT()**: 文字列を連結（MySQL固有）

**ウィンドウ関数:**
- **ROW_NUMBER()**: 行番号を付与
- **RANK()**: ランクを付与（同順位あり、次の順位は飛ぶ）
- **DENSE_RANK()**: 密なランクを付与（同順位あり、次の順位は連続）
- **LAG()/LEAD()**: 前後の行の値を取得

**サブクエリの種類:**
- **非相関サブクエリ**: 外部クエリと独立して実行
- **相関サブクエリ**: 外部クエリの値を参照
- **EXISTS句**: サブクエリの結果の存在をチェック
- **IN句**: 値の集合に含まれるかチェック

これらの機能により、高度なデータ分析が可能になります。`,
        quizzes: [
          {
            question: 'SQLのGROUP BY句と組み合わせて使用される集約関数でないものは？',
            options: ['COUNT', 'SUM', 'SUBSTRING', 'AVG'],
            correct: 2,
            explanation: 'SUBSTRINGは文字列を切り出す関数で、集約関数ではありません。'
          },
          {
            question: 'SQLのWINDOW関数でないものは？',
            options: ['ROW_NUMBER()', 'RANK()', 'DENSE_RANK()', 'GROUP_CONCAT()'],
            correct: 3,
            explanation: 'GROUP_CONCAT()はMySQL固有の集約関数で、標準SQLのWINDOW関数ではありません。'
          },
          {
            question: 'SQLのサブクエリで、外部クエリの値を参照するものは？',
            options: ['非相関サブクエリ', '相関サブクエリ', 'EXISTS句', 'IN句'],
            correct: 1,
            explanation: '相関サブクエリは外部クエリの列値を参照して実行されるサブクエリです。'
          },
          {
            question: 'データベースの分析関数LAG()の機能は？',
            options: ['前の行の値を取得', '次の行の値を取得', '最大値を取得', '最小値を取得'],
            correct: 0,
            explanation: 'LAG()関数は指定した行数だけ前の行の値を取得する分析関数です。'
          }
        ]
      },
      {
        title: 'CTE（共通テーブル式）とストアドプロシージャ',
        content: `SQLの高度な機能であるCTEとストアドプロシージャについて学習します。

**CTE（Common Table Expression）:**
- 一時的な結果セットを定義
- 複雑なクエリの可読性向上
- 再帰クエリの実装が可能
- 同一クエリ内でのみ有効

**ストアドプロシージャの特徴:**
- データベースサーバ上で実行される事前コンパイル済みプログラム
- 利点：
  - 実行速度の向上
  - ネットワークトラフィックの削減
  - セキュリティの向上（SQLインジェクション対策）
  - ビジネスロジックの集約
- 欠点：
  - ポータビリティの低下（DBMS固有）
  - デバッグの困難さ
  - バージョン管理の複雑化

**トリガー:**
- INSERT、UPDATE、DELETE時に自動実行
- BEFORE/AFTERのタイミング指定可能
- データ整合性の維持に利用
- SELECT文では実行されない

これらの機能により、データベース操作の効率化と高度化が実現できます。`,
        quizzes: [
          {
            question: 'SQLのCTE（Common Table Expression）の特徴は？',
            options: ['永続的なテーブル', '一時的な結果セット', 'インデックス作成可能', '複数セッションで共有'],
            correct: 1,
            explanation: 'CTEは1つのクエリ内で使用される一時的な結果セットです。'
          },
          {
            question: 'SQLのSTORED PROCEDUREの利点として適切でないものは？',
            options: ['性能の向上', 'セキュリティの向上', 'ポータビリティの向上', '保守性の向上'],
            correct: 2,
            explanation: 'ストアドプロシージャはDBMS固有の機能であり、ポータビリティ（移植性）は低下する傾向があります。'
          },
          {
            question: 'SQLのTRIGGERが実行されるタイミングでないものは？',
            options: ['BEFORE INSERT', 'AFTER UPDATE', 'DURING SELECT', 'AFTER DELETE'],
            correct: 2,
            explanation: 'TRIGGERはINSERT、UPDATE、DELETEに対してBEFOREまたはAFTERで実行され、SELECTでは実行されません。'
          },
          {
            question: 'データベースのバインド変数の利点は？',
            options: ['実行計画の再利用', 'セキュリティの低下', '性能の低下', 'メモリ使用量の増加'],
            correct: 0,
            explanation: 'バインド変数により実行計画を再利用でき、SQLインジェクション対策にもなります。'
          }
        ]
      }
    ]
  },
  {
    id: 4,
    title: 'データベース設計',
    sections: [
      {
        title: '正規化理論',
        content: `データベース設計における正規化の概念と手法について学習します。

**正規化の目的:**
- データの冗長性の排除
- 更新異常の防止
- 挿入異常の防止
- 削除異常の防止

**正規形の種類:**
- **第1正規形（1NF）**: 各属性が原子値（分割不可能な値）のみを持つ
- **第2正規形（2NF）**: 1NFを満たし、部分関数従属を除去
- **第3正規形（3NF）**: 2NFを満たし、推移関数従属を除去
- **ボイス・コッド正規形（BCNF）**: 3NFをより厳密にした形
- **第4正規形（4NF）**: BCNFを満たし、多値従属を除去

**関数従属の種類:**
- **完全関数従属**: 主キー全体に依存
- **部分関数従属**: 主キーの一部に依存
- **推移関数従属**: 非キー属性を経由した依存

適切な正規化により、データの整合性と保守性が向上します。`,
        quizzes: [
          {
            question: 'データベースの正規化で、第1正規形の条件は？',
            options: ['部分関数従属の除去', '完全関数従属のみ', '原子値のみ格納', '推移関数従属の除去'],
            correct: 2,
            explanation: '第1正規形（1NF）は、各属性が原子値（分割不可能な値）のみを持つことが条件です。'
          },
          {
            question: 'データベースの冗長性排除の第2正規形の条件は？',
            options: ['原子値のみ', '部分関数従属の除去', '推移関数従属の除去', '多値従属の除去'],
            correct: 1,
            explanation: '第2正規形（2NF）は第1正規形を満たし、かつ部分関数従属を除去した形です。'
          }
        ]
      },
      {
        title: 'マルチテナント設計とデータマスキング',
        content: `現代のデータベース設計における重要な概念について学習します。

**マルチテナント設計:**
複数の顧客（テナント）が同一のアプリケーションやデータベースを共有する設計手法

**マルチテナント設計の主なアプローチ:**
1. **共有データベース・共有スキーマ**: 全テナントが同じDB・スキーマを使用
2. **共有データベース・分離スキーマ**: 同じDBで各テナントが独自スキーマを使用
3. **分離データベース**: 各テナントが独立したデータベースを使用

**データマスキング:**
本番環境のデータを開発・テスト環境で安全に使用するための技術

**マスキング手法:**
- **静的マスキング**: データベースから抽出時にマスキング
- **動的マスキング**: アクセス時にリアルタイムでマスキング
- **仮名化**: 個人を特定できない形に変換
- **匿名化**: 完全に個人特定不可能にする

これらの設計手法により、セキュリティと効率性を両立できます。`,
        quizzes: [
          {
            question: 'データベースのマルチテナント設計のアプローチでないものは？',
            options: ['共有データベース・共有スキーマ', '共有データベース・分離スキーマ', '分離データベース', '分散データベース'],
            correct: 3,
            explanation: 'マルチテナント設計の主なアプローチは、共有/分離の組み合わせによる3つの方式です。'
          },
          {
            question: 'データベースのデータマスキングの目的は？',
            options: ['性能向上', '機密データの保護', 'データ圧縮', '冗長性排除'],
            correct: 1,
            explanation: 'データマスキングは本番データを開発/テスト環境で安全に使用するため、機密性を保護します。'
          }
        ]
      }
    ]
  },
  {
    id: 5,
    title: 'インデックス・パフォーマンス',
    sections: [
      {
        title: 'インデックス設計と最適化',
        content: `データベースの性能向上に重要なインデックス設計について学習します。

**インデックスの基本概念:**
- **目的**: 検索性能の向上
- **トレードオフ**: 検索は高速化するが、更新時のオーバーヘッドが発生
- **選択性**: カーディナリティが高い列ほどインデックス効果大

**インデックスの種類:**
- **B+ツリーインデックス**:
  - リーフノードにのみデータを格納
  - 範囲検索に適している
  - 最も一般的なインデックス構造
- **ハッシュインデックス**: 等価検索に特化
- **ビットマップインデックス**: カーディナリティが低い列に適用

**Columnstore index:**
- 列指向の格納方式
- 分析クエリ（OLAP）の性能向上
- データ圧縮効果が高い
- OLTP性能には不向き

**インデックス設計の考慮点:**
- WHERE句で頻繁に使用される列
- ORDER BY句で使用される列
- JOIN条件で使用される列
- 複合インデックスの列順序

適切なインデックス設計により、システム全体の性能が大幅に向上します。`,
        quizzes: [
          {
            question: 'データベースのインデックスの主な目的は？',
            options: ['データの暗号化', '検索性能の向上', 'データの圧縮', 'バックアップの高速化'],
            correct: 1,
            explanation: 'インデックスは検索性能を向上させるためのデータ構造です。'
          },
          {
            question: 'データベースのB+ツリーインデックスの特徴は？',
            options: ['リーフノードにのみデータ', '全ノードにデータ', 'ランダムアクセス不可', 'ソート不可'],
            correct: 0,
            explanation: 'B+ツリーではリーフノードにのみ実際のデータが格納され、範囲検索に適しています。'
          },
          {
            question: 'データベースのColumnstore indexの利点は？',
            options: ['OLTP性能向上', '分析クエリ性能向上', 'ストレージ使用量増加', 'インデックス作成不可'],
            correct: 1,
            explanation: 'Columnstore indexは列指向の格納により、集計や分析クエリの性能を大幅に向上させます。'
          },
          {
            question: 'データベースのカーディナリティとは？',
            options: ['テーブル数', '行数', '列の一意値の数', 'インデックス数'],
            correct: 2,
            explanation: 'カーディナリティは列に含まれる一意な値の数を表します。'
          }
        ]
      },
      {
        title: 'パーティショニングと性能チューニング',
        content: `大容量データベースの性能最適化技術について学習します。

**パーティショニング:**
大きなテーブルを小さな管理単位に分割する技術

**パーティショニングの種類:**
- **水平分割（Horizontal Partitioning）**: 行による分割
- **垂直分割（Vertical Partitioning）**: 列による分割
- **レンジパーティション**: 値の範囲で分割
- **ハッシュパーティション**: ハッシュ値で分割

**パーティショニングの利点:**
- クエリ性能の向上
- 管理の簡素化
- 並列処理の向上
- パーティション・プルーニング効果

**シャーディング:**
データを複数のデータベースインスタンスに分散配置
- スケーラビリティの向上
- 負荷の分散
- JOIN処理の複雑化（欠点）

**Micro-partitioning:**
小さな単位でのパーティション分割
- クエリ性能とメタデータ管理の最適化
- クラウドデータベースで採用

**性能指標:**
- **TPS（Transactions Per Second）**: 1秒間に処理できるトランザクション数
- **QPS（Queries Per Second）**: 1秒間に処理できるクエリ数
- **IOPS（I/O Operations Per Second）**: 1秒間のI/O操作数

これらの技術により、大規模データベースの性能と拡張性が実現できます。`,
        quizzes: [
          {
            question: 'データベースのパーティショニングの利点として適切でないものは？',
            options: ['クエリ性能の向上', '管理の簡素化', 'データの圧縮', '並列処理の向上'],
            correct: 2,
            explanation: 'パーティショニングは性能と管理性の向上が主目的で、データ圧縮は直接的な利点ではありません。'
          },
          {
            question: 'データベースの垂直分割（Vertical Partitioning）とは？',
            options: ['行による分割', '列による分割', '時間による分割', 'ハッシュによる分割'],
            correct: 1,
            explanation: '垂直分割は列（カラム）ごとにテーブルを分割する手法です。'
          },
          {
            question: 'データベースのシャーディングの利点として適切でないものは？',
            options: ['スケーラビリティの向上', '性能の向上', 'JOIN処理の高速化', '負荷の分散'],
            correct: 2,
            explanation: 'シャーディングでは異なるシャード間のJOIN処理が複雑になり、通常は性能が低下します。'
          },
          {
            question: 'データベースの性能指標で、1秒間に処理できるトランザクション数を表すのは？',
            options: ['QPS', 'TPS', 'RPS', 'IOPS'],
            correct: 1,
            explanation: 'TPS（Transactions Per Second）は1秒間に処理できるトランザクション数を表す指標です。'
          },
          {
            question: 'データベースのパーティション・プルーニングの効果は？',
            options: ['データの圧縮', '不要なパーティションの除外', 'インデックスの作成', 'ロックの取得'],
            correct: 1,
            explanation: 'パーティション・プルーニングは検索条件に基づいて不要なパーティションを除外し、性能を向上させます。'
          },
          {
            question: 'データベースのMicro-partitioningの利点は？',
            options: ['管理の複雑化', 'クエリ性能とメタデータ管理の最適化', 'ストレージ増加', 'セキュリティ低下'],
            correct: 1,
            explanation: 'Micro-partitioningは小さな単位でのパーティション分割により、クエリ性能とメタデータ管理を最適化します。'
          }
        ]
      },
      {
        title: 'インメモリ処理と圧縮技術',
        content: `高性能データベースシステムのための最新技術について学習します。

**インメモリ処理:**
データをメモリ上に配置して高速処理を実現する技術

**インメモリ処理の利点:**
- 処理速度の大幅向上
- ディスクI/Oの削減
- リアルタイム分析の実現
- 低レイテンシの実現

**データ圧縮技術:**
ストレージ効率化と転送速度向上のための技術

**圧縮方式の種類:**
- **行指向圧縮**: 各行を個別に圧縮（OLTPに適用）
- **列指向圧縮**: 列ごとに圧縮（OLAPに適用）
- **辞書圧縮**: 重複データを辞書で管理
- **ランレングス圧縮**: 連続する同一値を圧縮

**Zero-copy operation:**
データのメモリコピーを削減する技術
- CPU使用率の改善
- メモリ使用量の削減
- スループットの向上

**Immutable storage:**
データの不変性を保つストレージ技術
- データの一貫性保証
- 履歴管理の簡素化
- 並行アクセスの安全性

これらの技術により、次世代の高性能データベースシステムが実現されています。`,
        quizzes: [
          {
            question: 'データベースのインメモリ処理の利点は？',
            options: ['ストレージ容量の削減', '処理速度の向上', 'データの永続化', '消費電力の削減'],
            correct: 1,
            explanation: 'インメモリ処理はディスクI/Oを削減し、大幅な処理速度向上を実現します。'
          },
          {
            question: 'データベースの圧縮技術で、行指向圧縮の特徴は？',
            options: ['列ごとに圧縮', '行ごとに圧縮', 'ページ単位で圧縮', 'テーブル全体を圧縮'],
            correct: 1,
            explanation: '行指向圧縮は各行を個別に圧縮する方式で、OLTPシステムに適しています。'
          },
          {
            question: 'データベースのZero-copy operationの利点は？',
            options: ['データ暗号化', 'メモリコピー削減', 'ディスク容量削減', 'ネットワーク暗号化'],
            correct: 1,
            explanation: 'Zero-copy operationはデータのメモリコピーを削減し、CPU使用率とメモリ使用量を改善します。'
          },
          {
            question: 'データベースのImmutable storageの特徴は？',
            options: ['データの頻繁な更新', 'データの不変性', 'リアルタイム処理', 'メモリ使用量削減'],
            correct: 1,
            explanation: 'Immutable storageはデータの不変性を保ち、変更時は新しいバージョンを作成します。'
          },
          {
            question: 'データベースのインデックス最適化で重要な指標は？',
            options: ['テーブル数', 'カーディナリティ', '行数', 'ファイルサイズ'],
            correct: 1,
            explanation: 'カーディナリティ（一意値の数）が高い列ほどインデックスの効果が高くなります。'
          }
        ]
      }
    ]
  },
  {
    id: 6,
    title: '同期制御・トランザクション',
    sections: [
      {
        title: 'ACID特性とトランザクション管理',
        content: `データベースの信頼性を保つトランザクション処理について学習します。

**ACID特性:**
- **Atomicity（原子性）**: トランザクションは全実行か全取消し
- **Consistency（一貫性）**: データベースの整合性を保持
- **Isolation（独立性）**: 複数トランザクションの相互影響を制御
- **Durability（永続性）**: コミット後のデータ永続化保証

**分離レベル:**
1. **READ UNCOMMITTED**: ダーティリード、ファントムリード、非反復読み取りが発生
2. **READ COMMITTED**: ダーティリードを防止
3. **REPEATABLE READ**: ダーティリード、非反復読み取りを防止
4. **SERIALIZABLE**: すべての異常を防止、最も厳格

**スナップショット分離:**
- トランザクション開始時点のデータ読み取り一貫性を保証
- MVCCと組み合わせて実装
- ファントムリードの防止が可能

**WAL（Write-Ahead Logging）:**
- データ変更前にログを記録
- 障害回復の実現
- 再実行と取り消しの両方をサポート

これらの仕組みにより、データベースの信頼性と一貫性が保たれます。`,
        quizzes: [
          {
            question: 'トランザクションのACID特性のうち、「一貫性」を表すのは？',
            options: ['Atomicity', 'Consistency', 'Isolation', 'Durability'],
            correct: 1,
            explanation: 'Consistencyは一貫性を表し、トランザクション実行前後でデータの整合性が保たれることを意味します。'
          },
          {
            question: 'データベースのスナップショット分離レベルの特徴は？',
            options: ['ダーティリード発生', 'ファントムリード発生', '読み取り一貫性保証', 'デッドロック頻発'],
            correct: 2,
            explanation: 'スナップショット分離はトランザクション開始時点のデータの読み取り一貫性を保証します。'
          },
          {
            question: 'データベースのWAL（Write-Ahead Logging）の目的は？',
            options: ['データの暗号化', '障害回復の実現', 'データの圧縮', '検索性能の向上'],
            correct: 1,
            explanation: 'WALはデータ変更前にログを書き込むことで、障害時の回復を可能にします。'
          }
        ]
      },
      {
        title: 'ロック制御とMVCC',
        content: `データベースの並行制御技術について学習します。

**ロック制御:**
複数のトランザクションが同時にデータにアクセスする際の競合制御

**ロックの種類:**
- **共有ロック（Sロック）**: 読み取り専用、他の読み取りは許可
- **排他ロック（Xロック）**: 書き込み用、他のアクセス禁止
- **更新ロック（Uロック）**: 将来の更新予約
- **インテンション・ロック**: 階層ロックの効率化

**デッドロック対策:**
- **タイムアウト設定**: 一定時間後に強制終了
- **ロック順序の統一**: デッドロック発生の回避
- **2相ロック**: Growing/Shrinking相の明確化
- **ロック時間の延長**: 逆効果（避けるべき）

**MVCC（Multi-Version Concurrency Control）:**
複数バージョンを管理することで並行性を向上

**MVCCの特徴:**
- ロックフリーの読み取り
- 読み取りと書き込みの競合回避
- スナップショット分離の実現
- 書き込み間の競合は残存

**オプティミスティック・ロック:**
- 楽観的な並行制御
- 更新時に競合をチェック
- バージョン番号による実装

これらの技術により、高い並行性とデータ一貫性を両立できます。`,
        quizzes: [
          {
            question: 'データベースの並行制御で、読み取り専用トランザクションでも取得するロックは？',
            options: ['共有ロック', '排他ロック', '更新ロック', 'スキーマロック'],
            correct: 0,
            explanation: '読み取り専用トランザクションは共有ロック（Sロック）を取得し、他の読み取りは許可しますが書き込みはブロックします。'
          },
          {
            question: 'データベースの同期制御で、デッドロックを防ぐ方法として適切でないものは？',
            options: ['タイムアウト設定', 'ロック順序の統一', 'ロック時間の延長', '2相ロック'],
            correct: 2,
            explanation: 'ロック時間の延長はデッドロックの解決ではなく、むしろ発生確率を高める可能性があります。'
          },
          {
            question: 'データベースのMVCC（Multi-Version Concurrency Control）の特徴は？',
            options: ['ロックフリーの読み取り', '書き込み性能の低下', 'デッドロックの発生', 'メモリ使用量の削減'],
            correct: 0,
            explanation: 'MVCCは複数バージョンを管理することで、読み取り処理をロックフリーで実行できます。'
          },
          {
            question: 'データベースのオプティミスティック・ロックの特徴は？',
            options: ['事前にロック取得', '更新時に競合チェック', 'デッドロック頻発', '読み取り不可'],
            correct: 1,
            explanation: 'オプティミスティック・ロックは更新時にバージョン番号等で競合をチェックする楽観的制御です。'
          }
        ]
      },
      {
        title: 'バックアップ・リカバリとコネクション管理',
        content: `データベースの運用に重要なバックアップとコネクション管理について学習します。

**バックアップ方式:**
- **完全バックアップ**: 全データを毎回保存
- **差分バックアップ**: 前回の完全バックアップからの変更分のみ
- **増分バックアップ**: 前回のバックアップからの変更分のみ
- **ログバックアップ**: トランザクションログのみ保存

**Change Data Capture（CDC）:**
データベースの変更を追跡する技術
- リアルタイムデータ統合
- レプリケーション支援
- 監査ログの生成

**Time Travel機能:**
過去の特定時点のデータ状態にアクセス
- ポイントインタイム・リカバリ
- 履歴データの分析
- 誤操作時の復旧

**コネクション管理:**
- **コネクションプーリング**:
  - コネクション確立コストの削減
  - リソースの効率的利用
  - 接続数の制御

**マテリアライズドビュー:**
- 実際にデータを格納する物理的ビュー
- クエリ性能の向上
- 定期的なリフレッシュが必要

これらの技術により、データベースシステムの可用性と運用効率が向上します。`,
        quizzes: [
          {
            question: 'データベースのバックアップ方式で、差分バックアップの特徴は？',
            options: ['全データを毎回保存', '前回の完全バックアップからの変更分のみ', '前回のバックアップからの変更分のみ', 'ログファイルのみ保存'],
            correct: 1,
            explanation: '差分バックアップは前回の完全バックアップ以降に変更されたデータのみを保存します。'
          },
          {
            question: 'データベースのChange Data Capture（CDC）の用途は？',
            options: ['データバックアップ', 'データ変更の追跡', 'インデックス最適化', 'クエリ高速化'],
            correct: 1,
            explanation: 'CDCはデータベースの変更を追跡し、リアルタイムでデータ統合やレプリケーションを行います。'
          },
          {
            question: 'データベースのTime Travel機能とは？',
            options: ['将来データの予測', '過去の時点のデータアクセス', 'タイムゾーン変換', 'スケジュール実行'],
            correct: 1,
            explanation: 'Time Travel機能は過去の特定時点のデータ状態にアクセスできる機能です。'
          },
          {
            question: 'データベースのコネクションプーリングの利点は？',
            options: ['メモリ使用量の増加', 'コネクション確立コストの削減', 'セキュリティの低下', '処理速度の低下'],
            correct: 1,
            explanation: 'コネクションプーリングはコネクションを再利用することで、確立・切断のオーバーヘッドを削減します。'
          },
          {
            question: 'データベースのマテリアライズドビューの特徴は？',
            options: ['仮想的なテーブル', '実際にデータを格納', 'リアルタイム更新', 'インデックス不可'],
            correct: 1,
            explanation: 'マテリアライズドビューは実際にデータを格納する物理的なビューです。'
          },
          {
            question: 'データベースの暗号化方式で、行レベルでの暗号化を行うのは？',
            options: ['TDE（Transparent Data Encryption）', 'AES-256', 'RSA', 'SHA-256'],
            correct: 0,
            explanation: 'TDEは透過的なデータ暗号化技術で、行レベルやページレベルでのデータ暗号化を行います。'
          },
          {
            question: 'データベースの監査ログの主な目的は？',
            options: ['性能向上', 'セキュリティとコンプライアンス', 'データ圧縮', 'バックアップ高速化'],
            correct: 1,
            explanation: '監査ログはセキュリティ監視とコンプライアンス要件を満たすためのアクセス記録です。'
          },
          {
            question: 'データベースの論理削除と物理削除の違いは？',
            options: ['実行速度', '削除データの復旧可能性', 'ストレージ使用量', 'セキュリティレベル'],
            correct: 1,
            explanation: '論理削除は削除フラグによる論理的な削除で復旧可能、物理削除は実際にデータを削除し復旧困難です。'
          },
          {
            question: 'データベースのホットパッチ適用の利点は？',
            options: ['システム停止なしでの更新', '性能向上', 'データ圧縮', 'セキュリティ強化'],
            correct: 0,
            explanation: 'ホットパッチはシステムを停止することなく、稼働中にパッチやアップデートを適用できる技術です。'
          }
        ]
      }
    ]
  },
  {
    id: 7,
    title: '最新技術・クラウドDB',
    sections: [
      {
        title: 'クラウドネイティブデータベース',
        content: `クラウド環境に最適化された次世代データベース技術について学習します。

**Serverless Database:**
サーバー管理が不要な自動スケーリングデータベース
- **特徴**:
  - 使用量に応じた課金
  - 自動スケーリング
  - 必要時のみ稼働（24時間稼働不要）
  - 運用管理の簡素化

**Cloud-native Database設計原則:**
- **弾力性（Elasticity）**: 需要に応じた自動スケーリング
- **耐障害性（Fault tolerance）**: 障害に対する自動回復
- **単一障害点の除去**: 冗長化による高可用性
- **マイクロサービス対応**: API駆動のアーキテクチャ

**Federated Query:**
複数の異なるデータソースを統合して検索
- 異種データベース間のクエリ実行
- データレイクとの統合
- リアルタイム分析の実現

**Auto-tuning:**
ワークロードを分析して自動的に性能最適化
- インデックスの自動作成・削除
- パラメータの自動調整
- クエリ実行計画の最適化

**Multi-model Database:**
複数のデータモデルを統合的に扱う
- 文書、グラフ、キー・バリューの統合
- 単一システムでの多様なデータ処理
- 運用コストの削減

これらの技術により、クラウド時代の柔軟で効率的なデータ基盤が実現されます。`,
        quizzes: [
          {
            question: 'Serverless databaseの特徴として適切でないものは？',
            options: ['使用量に応じた課金', 'サーバー管理不要', '自動スケーリング', '24時間稼働必須'],
            correct: 3,
            explanation: 'Serverless databaseは必要に応じて自動的にスケールし、使用しない時は停止してコストを削減できます。'
          },
          {
            question: 'Cloud-native databaseの設計原則でないものは？',
            options: ['弾力性(Elasticity)', '耐障害性(Fault tolerance)', '単一障害点の除去', 'オンプレミス専用設計'],
            correct: 3,
            explanation: 'Cloud-native databaseはクラウド環境に最適化されており、オンプレミス専用設計は該当しません。'
          },
          {
            question: 'データベースのFederated queryの機能は？',
            options: ['単一データベース内検索', '複数データソースの統合検索', 'データバックアップ', 'インデックス作成'],
            correct: 1,
            explanation: 'Federated queryは複数の異なるデータソースを統合して、単一のクエリで検索できる機能です。'
          },
          {
            question: 'データベースのAuto-tuningの目的は？',
            options: ['手動設定の増加', '自動的な性能最適化', 'セキュリティ向上', 'データ暗号化'],
            correct: 1,
            explanation: 'Auto-tuningはワークロードを分析して自動的にインデックスやパラメータを最適化し、性能を向上させます。'
          },
          {
            question: 'Multi-model databaseの利点は？',
            options: ['単一データモデルのみ', '複数データモデルの統合', 'シンプルな構造', '従来技術のみ使用'],
            correct: 1,
            explanation: 'Multi-model databaseは文書、グラフ、キー・バリューなど複数のデータモデルを統合的に扱えます。'
          }
        ]
      },
      {
        title: 'AI・ML統合とVector Database',
        content: `AI・機械学習時代のデータベース技術について学習します。

**Vector Database:**
高次元ベクトルデータに特化したデータベース
- **主な用途**:
  - 類似性検索とAI/ML
  - 画像・音声・テキストの埋め込み表現
  - レコメンデーションシステム
  - 自然言語処理の意味検索

**Streaming ETL:**
リアルタイムでのデータ処理パイプライン
- バッチ処理からストリーミング処理への移行
- 低レイテンシデータ処理
- リアルタイム機械学習パイプライン

**NewSQL:**
従来のSQL機能とスケーラビリティを両立
- **特徴**:
  - ACIDサポートとスケーラビリティの両立
  - 分散環境での高性能
  - SQL互換性の維持
  - 水平スケーリング対応

**Graph Database:**
グラフ構造に特化したデータベース
- **クエリ言語**: Cypher（Neo4j等で使用）
- **用途**:
  - ソーシャルネットワーク分析
  - 知識グラフ
  - 推薦システム
  - 不正検知

**分散処理とCAP定理:**
- **C（Consistency）**: 一貫性
- **A（Availability）**: 可用性
- **P（Partition tolerance）**: 分断耐性
- 3つすべては同時に満たせない

**Eventual Consistency:**
NoSQLでの結果的一貫性
- 時間が経てば最終的に一貫性が保たれる
- 高可用性と分散性を優先

これらの最新技術により、AI・ML時代のデータ活用が加速されます。`,
        quizzes: [
          {
            question: 'データベースのVector databaseの主な用途は？',
            options: ['従来のリレーショナルデータ', '類似性検索とAI/ML', 'ファイルストレージ', 'キューイング'],
            correct: 1,
            explanation: 'Vector databaseは高次元ベクトルデータの類似性検索やAI/ML用途に特化したデータベースです。'
          },
          {
            question: 'データベースのGraph databaseのクエリ言語として一般的なものは？',
            options: ['SQL', 'Cypher', 'JavaScript', 'Python'],
            correct: 1,
            explanation: 'CypherはNeo4jなどのGraph databaseで使用される、グラフ構造に特化したクエリ言語です。'
          },
          {
            question: 'データベースのStreaming ETLの特徴は？',
            options: ['バッチ処理のみ', 'リアルタイムデータ処理', '手動実行のみ', '過去データのみ処理'],
            correct: 1,
            explanation: 'Streaming ETLはリアルタイムでデータの抽出、変換、読み込みを行う連続的な処理方式です。'
          },
          {
            question: 'NewSQLデータベースの特徴は？',
            options: ['SQLサポートなし', 'ACIDサポートなし', 'スケーラビリティとACIDの両立', '単一ノードのみ'],
            correct: 2,
            explanation: 'NewSQLは従来のSQL機能とACID特性を保ちながら、水平スケーラビリティを実現します。'
          },
          {
            question: 'データベースの分散処理で、CAP定理の3つの特性に含まれないものは？',
            options: ['一貫性(Consistency)', '可用性(Availability)', '分断耐性(Partition tolerance)', '効率性(Efficiency)'],
            correct: 3,
            explanation: 'CAP定理は一貫性、可用性、分断耐性の3つの特性について述べており、効率性は含まれません。'
          },
          {
            question: 'NoSQLのEventual Consistencyとは？',
            options: ['即座に一貫性を保証', '最終的に一貫性を保証', '一貫性を保証しない', '強い一貫性を保証'],
            correct: 1,
            explanation: 'Eventual Consistency（結果的一貫性）は時間が経てば最終的に一貫性が保たれることを意味します。'
          },
          {
            question: 'データベースのエッジコンピューティング対応で重要な要素は？',
            options: ['集中処理', '分散配置と低レイテンシ', '大容量ストレージ', '高スペックサーバ'],
            correct: 1,
            explanation: 'エッジコンピューティングでは、データを処理する場所を分散配置し、低レイテンシを実現することが重要です。'
          },
          {
            question: 'データベースのブロックチェーン技術との統合で実現できることは？',
            options: ['高速処理', 'データの改ざん防止', 'ストレージ削減', 'クエリ最適化'],
            correct: 1,
            explanation: 'ブロックチェーン技術との統合により、データの改ざん防止と透明性の確保が実現できます。'
          },
          {
            question: 'データベースのQuantum-readyな設計とは？',
            options: ['量子コンピュータ対応', '現在の暗号化強化', '性能向上', '容量拡張'],
            correct: 1,
            explanation: 'Quantum-ready設計は、将来の量子コンピュータ脅威に対応するため、現在の暗号化方式を強化することです。'
          },
          {
            question: 'データベースのゼロダウンタイム移行で使用される技術は？',
            options: ['完全停止移行', 'オンライン移行とレプリケーション', '手動データコピー', 'バックアップリストア'],
            correct: 1,
            explanation: 'ゼロダウンタイム移行では、オンライン移行技術とリアルタイムレプリケーションを組み合わせてサービス停止なしで移行を実現します。'
          }
        ]
      }
    ]
  }
];